// Do not edit this file; automatically generated by gulp.

/* eslint-disable */
;(function(root, factory) {
  if (typeof define === 'function' && define.amd) { // AMD
    define(['./blockly_compressed.js'], factory);
  } else if (typeof exports === 'object') { // Node.js
    module.exports = factory(require('./blockly_compressed.js'));
  } else { // Browser
    root.Blockly.Java = factory(root.Blockly);
  }
}(this, function(Blockly) {
  'use strict';Blockly.Java=new Blockly.Generator("Java");Blockly.Java.addReservedWords("abstract,assert,boolean,break,case,catch,class,const,continue,default,do,double,else,enum,extends,final,finally,float,for,goto,if,implements,import,instanceof,int,interface,long,native,new,package,private,protected,public,return,short,static,strictfp,super,switch,synchronized,this,throw,throws,transient,try,void,volatile,while,false,null,true,abs,divmod,input,open,staticmethod,all,enumerate,int,ord,str,any,eval,isinstance,pow,sum,basestring,execfile,issubclass,print,super,bin,file,iter,property,tuple,bool,filter,len,range,type,bytearray,float,list,raw_input,unichr,callable,format,locals,reduce,unicode,chr,frozenset,long,reload,vars,classmethod,getattr,map,repr,xrange,cmp,globals,max,reversed,zip,compile,hasattr,memoryview,round,__import__,complex,hash,min,set,apply,delattr,help,next,setattr,buffer,dict,hex,object,slice,coerce,dir,id,oct,sorted,intern,equal");
Blockly.Java.ORDER_ATOMIC=0;Blockly.Java.ORDER_COLLECTION=1;Blockly.Java.ORDER_STRING_CONVERSION=1;Blockly.Java.ORDER_MEMBER=2;Blockly.Java.ORDER_FUNCTION_CALL=2;Blockly.Java.ORDER_POSTFIX=3;Blockly.Java.ORDER_EXPONENTIATION=3;Blockly.Java.ORDER_LOGICAL_NOT=3;Blockly.Java.ORDER_UNARY_SIGN=4;Blockly.Java.ORDER_MULTIPLICATIVE=5;Blockly.Java.ORDER_ADDITIVE=6;Blockly.Java.ORDER_BITWISE_SHIFT=7;Blockly.Java.ORDER_RELATIONAL=8;Blockly.Java.ORDER_EQUALITY=9;Blockly.Java.ORDER_BITWISE_AND=10;
Blockly.Java.ORDER_BITWISE_XOR=11;Blockly.Java.ORDER_BITWISE_OR=12;Blockly.Java.ORDER_LOGICAL_AND=13;Blockly.Java.ORDER_LOGICAL_OR=14;Blockly.Java.ORDER_CONDITIONAL=15;Blockly.Java.ORDER_ASSIGNMENT=16;Blockly.Java.ORDER_NONE=99;Blockly.Java.PASS="  {}\n";Blockly.Java.POSTFIX="";Blockly.Java.INDENT="    ";Blockly.Java.EXTRAINDENT="";Blockly.Java.variableTypes_={};Blockly.Java.blocklyTypes_={};Blockly.Java.AppName_="myApp";Blockly.Java.Package_="demo";Blockly.Java.Baseclass_="";
Blockly.Java.needImports_=[];Blockly.Java.Interfaces_=[];Blockly.Java.ExtraImports_=null;Blockly.Java.INLINEVARCLASS=!0;Blockly.Java.classes_=[];Blockly.Java.globals_={};Blockly.Java.targetType_=null;Blockly.Java.fileHeader='/*\n * Copyright (c) 2015, <<Your Name>>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * * Redistributions of source code must retain the above copyright notice, this\n *   list of conditions and the following disclaimer.\n * * Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n';
Blockly.Java.setAppName=function(a){a&&""!==a||(a="MyApp");this.AppName_=a};Blockly.Java.getAppName=function(){return Blockly.Java.variableDB_.getName(this.AppName_,"CLASS")};Blockly.Java.setPackage=function(a){a&&""!==a||(a="demo");this.Package_=a};Blockly.Java.forceUpdate=function(a){if(a.getDescendants)a=a.getDescendants();else if(a.getAllBlocks)a=a.getAllBlocks();else throw"Not Block or Workspace: "+a;for(var b=0;b<a.length;b++)if(a[b].onchange)a[b].onchange()};Blockly.Java.getPackage=function(){return this.Package_};
Blockly.Java.setBaseclass=function(a){this.Baseclass_=a};Blockly.Java.getBaseclass=function(){var a=this.Baseclass_;""!=a&&(a=Blockly.Java.variableDB_.getName(a,"CLASS"));return a};Blockly.Java.addInterface=function(a){goog.array.contains(this.Interfaces_,a)||this.Interfaces_.push(a)};Blockly.Java.getInterfaces=function(){return 0===this.Interfaces_.length?null:this.Interfaces_};
Blockly.Java.setGlobalVar=function(a,b,c){null!=Blockly.Variables.getLocalContext(a,b)||"undefined"!==typeof this.globals_[b]&&null!==this.globals_[b]||(this.globals_[b]=c)};Blockly.Java.GetVariableType=function(a){a=this.variableTypes_[a];a||(a="Var",Blockly.Java.provideVarClass());return a};Blockly.Java.GetBlocklyType=function(a){return this.blocklyTypes_[a]};Blockly.Java.addImport=function(a){a="import "+a+";";this.imports_[a]=a};
Blockly.Java.getImports=function(){if(this.ExtraImports_)for(var a=0;a<this.ExtraImports_.length;a++)this.addImport(this.ExtraImports_[a]);a=goog.object.getValues(this.imports_);goog.array.sort(a);return a.join("\n")};Blockly.Java.setExtraImports=function(a){this.ExtraImports_=a};Blockly.Java.setVarClassInline=function(a){this.INLINEVARCLASS=a};Blockly.Java.getClasses=function(){var a="",b;for(b in this.classes_)a+=this.classes_[b];a&&(a+="\n\n");return a};
Blockly.Java.setExtraClass=function(a,b){this.classes_[a]=b.join("\n")+"\n"};Blockly.Java.workspaceToCode_=Blockly.Java.workspaceToCode;
Blockly.Java.workspaceToCode=function(a,b){this.setAppName(a.options.appTitle);this.forceUpdate(a);a=this.workspaceToCode_(a,b);b=this.fileHeader+"package "+this.getPackage()+";\n\n"+this.getImports()+"\n\npublic class "+this.getAppName();var c=this.getBaseclass();""!=c&&(b+=" extends "+c);if(c=this.getInterfaces())for(var e=" implements ",d=0;d<c.length;d++)b+=e+c[d],e=", ";return b+=" {\n\n"+a+"\n}\n\n"+this.getClasses()};
Blockly.Java.getValueType=function(a,b){return(a=a.getInputTargetBlock(b))?a.outputConnection.check_:""};
Blockly.Java.provideVarClass=function(){this.INLINEVARCLASS?(Blockly.Java.addImport("java.text.DecimalFormat"),Blockly.Java.addImport("java.text.NumberFormat"),Blockly.Java.addImport("java.lang.Math"),Blockly.Java.addImport("java.util.Arrays"),Blockly.Java.addImport("java.util.Collections"),Blockly.Java.addImport("java.util.LinkedList"),Blockly.Java.addImport("java.util.List"),Blockly.Java.addImport("java.util.HashMap"),Blockly.Java.addImport("java.util.Map"),Blockly.Java.addImport("java.util.Objects"),
this.classes_.Var='/**\n *\n * @author bmoon\n */\nfinal class Var implements Comparable {\n\n    public enum Type {\n\n         STRING, INT, DOUBLE, LIST, NULL, UNKNOWN\n    };\n\n    private Type _type;\n    private Object _object;\n    private static final NumberFormat _formatter = new DecimalFormat("#.#####");\n\n    /**\n     * Construct a Var with an UNKNOWN type\n     *\n     */\n    public Var() {\n         _type = Type.UNKNOWN;\n    } // end var\n\n    /**\n     * Construct a Var and assign its contained object to that specified.\n     *\n     * @param object The value to set this object to\n     */\n    public Var(Object object) {\n         setObject(object);\n    } // end var\n\n    /**\n     * Construct a Var from a given Var\n     *\n     * @param var var to construct this one from\n     */\n    public Var(Var var) {\n         setObject(var.getObject());\n    } // end var\n\n    /**\n     * Static constructor to make a var from some value.\n     *\n     * @param val some value to construct a var around\n     * @return the Var object\n     */\n    public static Var valueOf(Object val) {\n         return new Var(val);\n    } // end valueOf\n\n    /**\n     * Get the type of the underlying object\n     *\n     * @return Will return the object\'s type as defined by Type\n     */\n    public Type getType() {\n         return _type;\n    } // end getType\n\n    /**\n     * Get the contained object\n     *\n     * @return the object\n     */\n    public Object getObject() {\n         return _object;\n    } // end getObject\n\n    /**\n     * Clone Object\n     *\n     * @return a new object equal to this one\n     */\n    public Object cloneObject() {\n         Var tempVar = new Var(this);\n         return tempVar.getObject();\n    } // end cloneObject\n\n    /**\n     * Get object as an int. Does not make sense for a "LIST" type object\n     *\n     * @return an integer whose value equals this object\n     */\n    public int getObjectAsInt() {\n         switch (getType()) {\n                case STRING:\n                     return Integer.parseInt((String) getObject());\n                case INT:\n                     return (int) getObject();\n                case DOUBLE:\n                     return new Double((double) getObject()).intValue();\n                case LIST:\n                     // has no meaning\n                     break;\n                default:\n                     // has no meaning\n                     break;\n         }\n         return 0;\n    } // end getObjectAsInt\n\n    /**\n     * Get object as a double. Does not make sense for a "LIST" type object.\n     *\n     * @return a double whose value equals this object\n     */\n    public double getObjectAsDouble() {\n         switch (getType()) {\n                case STRING:\n                     return Double.parseDouble((String) getObject());\n                case INT:\n                     return new Integer((int) getObject()).doubleValue();\n                case DOUBLE:\n                     return (double) getObject();\n                case LIST:\n                     // has no meaning\n                     break;\n                default:\n                     // has no meaning\n                     break;\n         }\n         return 0.0;\n    } // end get object as double\n\n    /**\n     * Get object as a string.\n     *\n     * @return The string value of the object. Note that for lists, this is a\n     * comma separated list of the form {x,y,z,...}\n     */\n    public String getObjectAsString() {\n         return this.toString();\n    } // end gotObjectAsString\n\n    /**\n     * Get the object as a list.\n     *\n     * @return a LinkedList whose elements are of type Var\n     */\n    public LinkedList<Var> getObjectAsList() {\n         return (LinkedList<Var>) getObject();\n    } // end getObjectAsList\n\n    /**\n     * If this object is a linked list, then calling this method will return the\n     * Var at the index indicated\n     *\n     * @param index the index of the Var to read (0 based)\n     * @return the Var at that index\n     */\n    public Var get(int index) {\n         return ((LinkedList<Var>) getObject()).get(index);\n    } // end get\n\n    /**\n     * If this object is a linked list, then calling this method will return the\n     * size of the linked list.\n     *\n     * @return size of list\n     */\n    public int size() {\n         return ((LinkedList<Var>) getObject()).size();\n    } // end size\n\n    /**\n     * Set the value of of a list at the index specified. Note that this is only\n     * value if this object is a list and also note that index must be in\n     * bounds.\n     *\n     * @param index the index into which the Var will be inserted\n     * @param var the var to insert\n     */\n    public void set(int index, Var var) {\n         ((LinkedList<Var>) getObject()).add(index, var);\n    } // end set\n\n    /**\n     * Add all values from one List to another. Both lists are Var objects that\n     * contain linked lists.\n     *\n     * @param var The list to add\n     */\n    public void addAll(Var var) {\n         ((LinkedList<Var>) getObject()).addAll(var.getObjectAsList());\n    } // end addAll\n\n    /**\n     * Set the value of the underlying object. Note that the type of Var will be\n     * determined when setObject is called.\n     *\n     * @param val the value to set this Var to\n     */\n    public void setObject(Object val) {\n         this._object = val;\n         inferType();\n         // make sure each element of List is Var if type is list\n         if (_type.equals(Var.Type.LIST)) {\n                LinkedList<Var> myList = new LinkedList<>();\n                for (Object obj : this.getObjectAsList()) {\n                     myList.add(new Var(obj));\n                }\n                this._object = myList;\n         }\n    } // end setObject\n\n    /**\n     * Add a new member to a Var that contains a list. If the Var current is not\n     * of type "LIST", then this Var will be converted to a list, its current\n     * value will then be stored as the first member and this new member added\n     * to it.\n     *\n     * @param member The new member to add to the list\n     */\n    public void add(Var member) {\n         if (_type.equals(Var.Type.LIST)) {\n                // already a list\n                ((LinkedList<Var>) _object).add(member);\n         } else {\n                // not current a list, change it\n                LinkedList<Var> temp = new LinkedList<>();\n                temp.add(new Var(member));\n                setObject(temp);\n         }\n    } // end add\n\n    /**\n     * Increment Object by some value.\n     *\n     * @param inc The value to increment by\n     */\n    public void incrementObject(double inc) {\n         switch (getType()) {\n                case STRING:\n                     // has no meaning\n                     break;\n                case INT:\n                     this.setObject((double) (this.getObjectAsInt() + inc));\n                     break;\n                case DOUBLE:\n                     this.setObject((double) (this.getObjectAsDouble() + inc));\n                     break;\n                case LIST:\n                     for (Var myVar : this.getObjectAsList()) {\n                            myVar.incrementObject(inc);\n                     }\n                     break;\n                default:\n                     // has no meaning\n                     break;\n         } // end switch\n    } // end incrementObject\n\n    /**\n     * Increment Object by some value\n     *\n     * @param inc The value to increment by\n     */\n    public void incrementObject(int inc) {\n         switch (getType()) {\n                case STRING:\n                     // has no meaning\n                     break;\n                case INT:\n                     this.setObject((int) (this.getObjectAsInt() + inc));\n                     break;\n                case DOUBLE:\n                     this.setObject((double) (this.getObjectAsDouble() + inc));\n                     break;\n                case LIST:\n                     for (Var myVar : this.getObjectAsList()) {\n                            myVar.incrementObject(inc);\n                     }\n                     break;\n                default:\n                     // has no meaning\n                     break;\n         }// end switch\n    } // end incrementObject\n\n    @Override\n    public int hashCode() {\n         int hash = 5;\n         hash = 43 * hash + Objects.hashCode(this._type);\n         hash = 43 * hash + Objects.hashCode(this._object);\n         return hash;\n    }\n\n    /**\n     * Test to see if this object equals another one. This is done by converting\n     * both objects to strings and then doing a string compare.\n     *\n     * @param obj\n     * @return\n     */\n    @Override\n    public boolean equals(Object obj) {\n         final Var other = Var.valueOf(obj);\n         if (getType() == Var.Type.NULL || other.getType() == Var.Type.NULL) {\n                return getType().equals(other.getType());\n         }\n         return this.toString().equals(other.toString());\n    } // end equals\n\n    /**\n     * Check to see if this Var is less than some other var.\n     *\n     * @param var the var to compare to\n     * @return true if it is less than\n     */\n    public boolean lessThan(Var var) {\n         switch (getType()) {\n                case STRING:\n                     return this.getObjectAsString().compareTo(var.getObjectAsString()) < 0;\n                case INT:\n                     return this.getObjectAsInt() < var.getObjectAsDouble();\n                case DOUBLE:\n                     return this.getObjectAsDouble() < var.getObjectAsDouble();\n                case LIST:\n                     if (size() != var.size()) {\n                            return false;\n                     }\n                     if (!var.getType().equals(Var.Type.LIST)) {\n                            return false;\n                     }\n                     int index = 0;\n                     for (Var myVar : this.getObjectAsList()) {\n                            if (!myVar.lessThan(var.get(index))) {\n                                return false;\n                            }\n                     }\n                     return true;\n                default:\n                     return false;\n         }// end switch\n    } // end less than\n\n    /**\n     * Check to see if this var is less than or equal to some other var\n     *\n     * @param var the var to compare to\n     * @return true if this is less than or equal to var\n     */\n    public boolean lessThanOrEqual(Var var) {\n         switch (getType()) {\n                case STRING:\n                     return this.getObjectAsString().compareTo(var.getObjectAsString()) <= 0;\n                case INT:\n                     return this.getObjectAsInt() <= var.getObjectAsDouble();\n                case DOUBLE:\n                     return this.getObjectAsDouble() <= var.getObjectAsDouble();\n                case LIST:\n                     if (size() != var.size()) {\n                            return false;\n                     }\n                     if (!var.getType().equals(Var.Type.LIST)) {\n                            return false;\n                     }\n                     int index = 0;\n                     for (Var myVar : this.getObjectAsList()) {\n                            if (!myVar.lessThanOrEqual(var.get(index))) {\n                                 return false;\n                            }\n                     }\n                     return true;\n                case NULL:\n                     return (var.getType() == Var.Type.NULL);\n                default:\n                     return false;\n         }// end switch\n    } // end lessThanOrEqual\n\n    /**\n     * Check to see if this var is greater than a given var.\n     *\n     * @param var the var to compare to.\n     * @return true if this object is grater than the given var\n     */\n    public boolean greaterThan(Var var) {\n         return var.lessThan(this);\n    } // end greaterThan\n\n    /**\n     * Check to see if this var is greater than or equal to a given var\n     *\n     * @param var the var to compare to\n     * @return true if this var is greater than or equal to the given var\n     */\n    public boolean greaterThanOrEqual(Var var) {\n         return var.lessThanOrEqual(this);\n    } // end greaterThanOrEqual\n\n    /**\n     * Compare this object\'s value to another\n     *\n     * @param val the object to compare to\n     * @return the value 0 if this is equal to the argument; a value less than 0\n     * if this is numerically less than the argument; and a value greater than 0\n     * if this is numerically greater than the argument (signed comparison).\n     */\n    @Override\n    public int compareTo(Object val) {\n         // only instantiate if val is not instance of Var\n         Var var;\n         if (val instanceof Var) {\n                var = (Var) val;\n         } else {\n                var = new Var(val);\n         }\n         switch (getType()) {\n                case STRING:\n                     return this.getObjectAsString().compareTo(var.getObjectAsString());\n                case INT:\n                     if (var.getType().equals(Var.Type.INT)) {\n                            return ((Integer) this.getObjectAsInt()).compareTo(var.getObjectAsInt());\n                     } else {\n                            return ((Double) this.getObjectAsDouble()).compareTo(var.getObjectAsDouble());\n                     }\n                case DOUBLE:\n                     return ((Double) this.getObjectAsDouble()).compareTo(var.getObjectAsDouble());\n                case LIST:\n                     // doesn\'t make sense\n                     return Integer.MAX_VALUE;\n                default:\n                     // doesn\'t make sense\n                     return Integer.MAX_VALUE;\n         }// end switch\n    } // end compareTo\n\n    /**\n     * Convert this Var to a string format.\n     *\n     * @return the string format of this var\n     */\n    @Override\n    public String toString() {\n         switch (getType()) {\n                case STRING:\n                     return getObject().toString();\n                case INT:\n                     Integer i = (int) getObject();\n                     return i.toString();\n                case DOUBLE:\n                     Double d = (double) _object;\n                     return _formatter.format(d);\n                case LIST:\n                     LinkedList<Var> ll = (LinkedList) getObject();\n                     StringBuilder sb = new StringBuilder();\n                     boolean first = true;\n                     for (Var v : ll) {\n                            if (first) {\n                                 first = false;\n                                 sb.append("{");\n                            } else {\n                                 sb.append(", ");\n                            }\n                            sb.append(v.toString());\n                     } // end for each Var\n                     sb.append("}");\n                     return sb.toString();\n                case NULL:\n                     return null;\n                default:\n                     return getObject().toString();\n         }// end switch\n    } // end toString\n\n    /**\n     * Internal method for inferring the "object type" of this object. When it\n     * is done, it sets the private member value of _type. This will be\n     * referenced later on when various method calls are made on this object.\n     */\n    private void inferType() {\n         if (_object == null) {\n             _type = Type.NULL;\n         } else if (_object instanceof Var) {\n            Var oldObj = (Var)_object;\n            _type = oldObj.getType();\n            _object = oldObj.getObject();\n         } else if (_object instanceof String) {\n                _type = Type.STRING;\n         } else {\n         // must be a number or a list\n                // try to see if its a double\n                try {\n                     Double d = (double) _object;\n                     // it was a double, so keep going\n                     _type = Type.DOUBLE;\n                } catch (Exception ex) {\n                     // not a double, see if it is an integer\n                     try {\n                            Integer i = (int) _object;\n                            // it was an integer\n                            _type = Type.INT;\n                     } catch (Exception ex2) {\n                            // not a double or integer, might be an array\n                            if (_object instanceof LinkedList) {\n                                 _type = Type.LIST;\n                            } else if (_object instanceof List) {\n                                 _type = Type.LIST;\n                                 _object = new LinkedList<>((List) _object);\n                            } else {\n                                 _type = Type.UNKNOWN;\n                            }\n                     } // end not an integer\n                } // end not a double\n         } // end else not a string\n    } // end inferType\n\n    static double math_sum(Var myList) {\n         double sum = 0;\n         LinkedList<Var> ll = myList.getObjectAsList();\n         for (Var var : ll) {\n                sum += var.getObjectAsDouble();\n         }\n         return sum;\n    }\n\n    static double math_min(Var myList) {\n         double min = Double.MAX_VALUE;\n         double d;\n         LinkedList<Var> ll = myList.getObjectAsList();\n         for (Var var : ll) {\n                d = var.getObjectAsDouble();\n                if (d < min) {\n                     min = d;\n                }\n         }\n         return min;\n    }\n\n    static double math_max(Var myList) {\n         double max = Double.MIN_VALUE;\n         double d;\n         LinkedList<Var> ll = myList.getObjectAsList();\n         for (Var var : ll) {\n                d = var.getObjectAsDouble();\n                if (d > max) {\n                     max = d;\n                }\n         }\n         return max;\n    }\n\n    static double math_mean(Var myList) {\n         return Var.math_sum(myList) / myList.size();\n    }\n\n    static double math_median(Var myList) {\n         LinkedList<Var> ll = myList.getObjectAsList();\n         Collections.sort(ll);\n         int length = myList.size();\n         int middle = length / 2;\n         if (length % 2 == 1) {\n                return ll.get(middle).getObjectAsDouble();\n         } else {\n                double d1 = ll.get(middle - 1).getObjectAsDouble();\n                double d2 = ll.get(middle).getObjectAsDouble();\n                return (d1 + d2) / 2.0;\n         }\n    }\n\n    static Var math_modes(Var myList) {\n         final Var modes = new Var();\n         final Map<Double, Double> countMap = new HashMap<Double, Double>();\n         double max = -1;\n         double d;\n         LinkedList<Var> ll = myList.getObjectAsList();\n         for (Var var : ll) {\n                d = var.getObjectAsDouble();\n                double count = 0;\n                if (countMap.containsKey(d)) {\n                     count = countMap.get(d) + 1;\n                } else {\n                     count = 1;\n                }\n                countMap.put(d, count);\n                if (count > max) {\n                     max = count;\n                }\n         }\n         for (final Map.Entry<Double, Double> tuple : countMap.entrySet()) {\n                if (tuple.getValue() == max) {\n                     modes.add(Var.valueOf(tuple.getKey().doubleValue()));\n                }\n         }\n         return modes;\n    }\n\n    static double math_standard_deviation(Var myList) {\n         double mean = math_mean(myList);\n         double size = myList.size();\n         double temp = 0;\n         double d;\n         LinkedList<Var> ll = myList.getObjectAsList();\n         for (Var var : ll) {\n                d = var.getObjectAsDouble();\n                temp += (mean - d) * (mean - d);\n         }\n         double variance = temp / size;\n         return Math.sqrt(variance);\n    }\n\n}\n'):
Blockly.Java.addImport("com.extreme.platform.application.Var")};Blockly.Java.typeMapping={Object:"Object",Array:"LinkedList",Map:"HashMap",Var:"Var",Boolean:"Boolean",String:"String",Colour:"String",Number:"double"};Blockly.Java.subtypeMapping={Object:"Object",Array:"LinkedList",Map:"HashMap",Var:"Var",Boolean:"Boolean",String:"String",Colour:"String",Number:"Double"};
Blockly.Java.mapType=function(a){var b=function(e,d){d&&0!==d.length||(console.log("Empty type. Using Var"),d=["Var"]);var g=d.shift(),f=g;e[f]?f=e[f]:Blockly.Blocks[f]&&Blockly.Blocks[f].GBPClass?f=Blockly.Blocks[f].GBPClass:Blockly.VariableTypeEquivalence[f]||(console.log("Unknown type for "+g+" using Var for "+f),f="Var");"Var"===f&&Blockly.Java.provideVarClass();0<d.length&&(e=b(Blockly.Java.subtypeMapping,d),f+="<"+e+">");return f},c=null;a&&(c=a.split(":"));return b(this.typeMapping,c)};
Blockly.Java.setTargetType=function(a){var b=this.targetType_;this.targetType_=a;return b};Blockly.Java.getTargetType=function(a){return this.targetType_};Blockly.Java.computeJavaType=function(a){a=Blockly.Variables.Intersection(a,a);a=Blockly.Variables.resolveTypes(a);return Blockly.Java.mapType(a)};
Blockly.Java.init=function(a,b){this.definitions_=Object.create(null);this.functionNames_=Object.create(null);this.imports_=Object.create(null);this.classes_=Object.create(null);this.globals_=Object.create(null);for(b=0;b<this.needImports_.length;b++)this.addImport(this.needImports_[b]);this.variableDB_?this.variableDB_.reset():this.variableDB_=new Blockly.Names(this.RESERVED_WORDS_);Blockly.VariableTypeEquivalence.Colour=["String"];b=Blockly.Variables.allVariables(a);this.blocklyTypes_=Blockly.Variables.allVariablesTypes(a);
for(var c in this.blocklyTypes_)b.push(c);for(a=0;a<b.length;a++)c=b[a],this.variableTypes_[c]=this.mapType(this.blocklyTypes_[c])};
Blockly.Java.finish=function(a){var b=[[],[]];for(g in this.definitions_)if("variables"!==g){var c=this.definitions_[g],e=1;if("function"!==typeof c){var d=c.split(" ",3);goog.array.contains(d,"static")&&(e=0)}b[e].push(g)}var g="";for(c in this.globals_){e="";d=this.GetVariableType(c);null!=this.globals_[c]&&""!==this.globals_[c]?e=" = "+this.globals_[c]:"Var"===d?e=" = new Var(0)":"Boolean"===d?e=" = false":"String"===d&&(e=' = ""');var f=Blockly.Java.variableDB_.getName(c,Blockly.Variables.NAME_TYPE);
g+="protected "+d+" "+f+e+";\n"}for(e=0;2>e;e++)for(d=b[e].sort(),f=0;f<d.length;f++){c=this.definitions_[d[f]];"function"===typeof c&&(c=c.call(this));var l="",k=c.split("(",2);if(2<=k.length&&-1===k[0].indexOf(";")){l="/**\n * Description goes here\n";var m=" *\n",h=k[0];h=h.split(" ");var n=h[h.length-2];h=k[1];h=h.split(")",1);h=h[0].trim();if(""!==h)for(k=h.split(","),h=0;h<k.length;h++){var p=k[h].split(" ");l+=m+" * @param "+p[p.length-1]+"\n";m=""}"void"!==n&&"public"!==n&&(l+=m+" * @return "+
n+"\n");l+=" */\n"}g+=l+c+"\n\n"}delete Blockly.Java.definitions_;delete Blockly.Java.functionNames_;Blockly.Java.variableDB_.reset();return g.replace(/\n\n+/g,"\n\n").replace(/\n*$/,"\n\n\n")+a};Blockly.Java.scrubNakedValue=function(a){return a+";\n"};Blockly.Java.quote_=function(a){return goog.string.quote(a)};
Blockly.Java.toStringCode=function(a,b){var c=a.getInputTargetBlock(b);if(!c)return"";a=Blockly.Java.valueToCode(a,b,Blockly.Java.ORDER_NONE);a=a.trim();""!==a&&'"'!==a.charAt(0)&&("variables_get"===c.type&&"Var"===Blockly.Java.GetVariableType(c.procedurePrefix_+c.getFieldValue("VAR"))?a+=".toString()":Blockly.isNumber(a)?a='"'+a+'"':"variables_get"!==c.type&&"Var"===Blockly.Java.GetVariableType(a)?a+=".toString()":(this.addImport("java.text.DecimalFormat"),this.addImport("java.text.NumberFormat"),
a=this.provideFunction_("blocklyToString",["public static String blocklyToString(Object object) {","    String result;","    if (object instanceof String) {","        result = (String) object;","    } else {","        // must be a number","        // might be a double","        try {","            Double d = (double) object;","            // it was a double, so keep going",'            NumberFormat formatter = new DecimalFormat("#.#####");',"            result = formatter.format(d);","","        } catch (Exception ex) {",
"            // not a double, see if it is an integer","            try {","                Integer i = (int) object;","                // format should be number with a decimal point","                result = i.toString();","            } catch (Exception ex2) {","                // not a double or integer",'                result = "UNKNOWN";',"            }","        }","    }","","  return result;","}"])+"("+a+")"));return a};
Blockly.Java.scrub_=function(a,b,c){var e="";if(!a.outputConnection||!a.outputConnection.targetConnection){var d=a.getCommentText();d&&(e+=this.prefixLines(d,"// ")+"\n");for(var g=0;g<a.inputList.length;g++)a.inputList[g].type==Blockly.INPUT_VALUE&&(d=a.inputList[g].connection.targetBlock())&&(d=this.allNestedComments(d))&&(e+=this.prefixLines(d,"// "))}g=this.POSTFIX;this.POSTFIX="";d=this.EXTRAINDENT;this.EXTRAINDENT="";a=a.nextConnection&&a.nextConnection.targetBlock();c=this.blockToCode(a,c);
""!=d&&(c=this.prefixLines(c,d));return e+b+c+g};
return Blockly.Java;
}));


//# sourceMappingURL=java_compressed.js.map
